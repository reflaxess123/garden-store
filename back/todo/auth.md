### Реализация авторизации в текущем проекте (Next.js с Supabase)

Текущая система авторизации в проекте `garden-store` построена на базе **Supabase Auth**. Это включает в себя использование клиентских библиотек Supabase для взаимодействия с аутентификационной частью Supabase и Prisma для работы с профилями пользователей.

#### 1. Модели и схемы данных (`src/features/auth/model.ts`)

Этот файл определяет Zod-схемы для валидации входных данных форм аутентификации и функции, которые напрямую взаимодействуют с Supabase Auth.

- **`signInSchema`**:

  - `email`: string, формат email.
  - `password`: string, не пустой.

- **`signUpSchema`**:

  - `email`: string, формат email.
  - `password`: string, минимум 6 символов, максимум 100.
  - `confirmPassword`: string, должен совпадать с `password`.

- **`resetPasswordSchema`**:
  - `email`: string, формат email.

**Основные функции аутентификации, использующие Supabase Client:**

- **`signInWithPassword(data: { email, password })`**:

  - Вызывает `supabaseClient.auth.signInWithPassword` для входа пользователя.
  - Возвращает `{ success: boolean, user: CustomUser | null, error: string | null }`.

- **`signUp(data: { email, password, confirmPassword })`**:

  - Вызывает `supabaseClient.auth.signUp` для регистрации нового пользователя.
  - При регистрации устанавливает `isAdmin: false` по умолчанию в `options.data`.
  - Обрабатывает сценарии, когда требуется подтверждение по электронной почте (пользователь создан, но `identities` пуст).
  - Возвращает `{ success: boolean, user: CustomUser | null, message?: string, error: string | null }`.

- **`sendPasswordResetEmail(email: string)`**:

  - Вызывает `supabaseClient.auth.resetPasswordForEmail` для отправки письма сброса пароля.
  - `redirectTo` настроен на `${process.env.NEXT_PUBLIC_BASE_URL}/auth/update-password`.
  - Возвращает `{ success: boolean, message?: string, error: string | null }`.

- **`updatePassword(password: string)`**:
  - Вызывает `supabaseClient.auth.updateUser` для обновления пароля текущего пользователя.
  - Возвращает `{ success: boolean, message?: string, error: string | null }`.

#### 2. Управление состоянием аутентификации на клиенте (`src/features/auth/AuthContext.tsx`)

Этот компонент предоставляет контекст аутентификации для всего приложения, позволяя дочерним компонентам получать доступ к данным пользователя и состоянию загрузки. Он использует пользовательский хук `useSession`.

#### 3. Хук управления сессией (`src/shared/lib/useSession.ts`)

Этот хук `useSession` является ключевым для управления сессией пользователя на стороне клиента:

- **Инициализация сессии**: При первой загрузке или изменении состояния аутентификации он вызывает `supabaseClient.auth.getSession()` для получения текущей сессии.
- **Получение `isAdmin`**: После получения данных пользователя из Supabase, хук выполняет дополнительный запрос к таблице `profiles` в вашей базе данных (через `supabaseClient.from("profiles").select("isAdmin").eq("id", session.user.id).single()`), чтобы определить, является ли пользователь администратором. Это важно, так как `isAdmin` не является стандартным полем Supabase Auth, а хранится в вашей пользовательской таблице `profiles`.
- **Отслеживание изменений состояния аутентификации**: Использует `supabaseClient.auth.onAuthStateChange()` для подписки на изменения состояния аутентификации (например, вход, выход, обновление токена) и соответствующего обновления состояния пользователя.
- **`CustomUser` интерфейс**: Расширяет стандартный объект `User` из Supabase, добавляя необязательное поле `isAdmin`.
- Возвращает объект `{ user, isLoading, isAuthenticated }`, где `isAuthenticated` определяется наличием объекта `user`.

#### 4. Взаимодействие с API-эндпоинтами

- Эндпоинты, такие как `POST /api/auth/signin` (как мы обсуждали в `endpoints.md`), используются для обработки запросов на аутентификацию на стороне сервера, а затем они взаимодействуют с Supabase Auth.
- Административные эндпоинты (`/api/admin/...`) и эндпоинты заказов (`/api/orders`) требуют аутентификации пользователя и часто дополнительно проверяют статус `isAdmin` пользователя.

### Рекомендации для миграции на Python FastAPI + Redis

При переходе на FastAPI с Redis для авторизации вам потребуется:

1.  **Заменить Supabase Auth на собственную реализацию авторизации**:

    - Вам нужно будет создать таблицы для пользователей (аналог `auth.users` в Supabase), возможно, с использованием SQLAlchemy ORM или других библиотек.
    - Реализовать функции для регистрации, входа, сброса пароля и обновления профиля пользователя.
    - Использовать библиотеку для хеширования паролей (например, `passlib` с `bcrypt` или `scrypt`).
    - Для управления сессиями или токенами можно использовать JWT (JSON Web Tokens).

2.  **Интеграция Redis для управления сессиями/токенами**:

    - **Для JWT**: Redis можно использовать как черный список для отозванных токенов или для хранения метаданных токенов (например, время истечения).
    - **Для традиционных сессий**: Redis идеально подходит для хранения сессий пользователей, если вы решите не использовать JWT.

3.  **Перенос логики `isAdmin`**:

    - Создайте таблицу `profiles` (или аналогичную) в вашей PostgreSQL базе данных, которая будет содержать поле `isAdmin` и ссылаться на таблицу пользователей.
    - При аутентификации пользователя, после проверки учетных данных, извлекайте статус `isAdmin` из этой таблицы.
    - Внедрите проверку `isAdmin` для административных эндпоинтов в FastAPI, используя зависимости (`Depends`).

4.  **Схемы валидации**:

    - Перепишите Zod-схемы на Pydantic модели, которые являются стандартными для FastAPI и обеспечивают валидацию данных запросов и ответов.

5.  **Эндпоинты авторизации**:

    - Реализуйте `/auth/signin`, `/auth/signup`, `/auth/reset-password`, `/auth/update-password` в FastAPI.
    - Обратите внимание на то, как происходит отправка электронных писем для сброса пароля. Вам потребуется интегрировать сторонний сервис электронной почты или настроить собственный.

6.  **Управление токенами и куками (если применимо)**:
    - FastAPI позволяет работать с JWT (например, с помощью `python-jose`) и устанавливать их в заголовки `Authorization` или куки.
